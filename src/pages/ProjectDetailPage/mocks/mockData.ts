export const DUMMY_PROJECT_DETAIL = {
  id: 1,
  name: "사이드픽👀",
  subName: "요즘 사이드 플젝 뭐함? 사이드픽 👀",
  overview: "데브코스 5기 육개짱팀의 좌충우돌 우당탕탕 프로젝트 개발 일대기",
  thumbnailUrl:
    "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-ec2.png",
  overviewImageUrl: [
    {
      id: 1,
      url: "https://i.namu.wiki/i/or0qAazlWncLp8HGOIfZZ5iD--tZTgw8WxsgCJ6JhYNwt27452r_ttkdtQNimpS5j1CavL8Z9HLjTOK51Df-tToMO-fxSWkKsgQKJuVW52it7UTnAjvr0rRrRRO6Hf4BsW_2y71iHeh_Lkomin_86Q.webp",
    },
    {
      id: 2,
      url: "https://i.namu.wiki/i/or0qAazlWncLp8HGOIfZZ5iD--tZTgw8WxsgCJ6JhYNwt27452r_ttkdtQNimpS5j1CavL8Z9HLjTOK51Df-tToMO-fxSWkKsgQKJuVW52it7UTnAjvr0rRrRRO6Hf4BsW_2y71iHeh_Lkomin_86Q.webp",
    },
  ],
  githubUrl: "https://github.com/side-peek",
  deployUrl: null,
  viewCount: 168,
  likeCount: 7,
  commentCount: 13,
  techStacks: [
    {
      id: 21,
      category: "프론트",
      skill: {
        id: 1,
        name: "AWS EC2",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-ec2.png",
      },
    },
    {
      id: 22,
      category: "백",
      skill: {
        id: 2,
        name: "AWS RDS",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-rds.png",
      },
    },
    {
      id: 23,
      category: "협업툴",
      skill: {
        id: 3,
        name: "AWS S3",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-s3.png",
      },
    },
    {
      id: 24,
      category: "프론트",
      skill: {
        id: 4,
        name: "Figma",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/figma.png",
      },
    },
    {
      id: 25,
      category: "기타 등등",
      skill: {
        id: 5,
        name: "Git",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/git-icon.png",
      },
    },
    {
      id: 26,
      category: "프론트",
      skill: {
        id: 6,
        name: "Github Actions",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/github-actions.png",
      },
    },
    {
      id: 27,
      category: "프론트",
      skill: {
        id: 7,
        name: "Github",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/github-icon.png",
      },
    },
    {
      id: 28,
      category: "백",
      skill: {
        id: 8,
        name: "Java",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/java.png",
      },
    },
    {
      id: 29,
      category: "협업툴",
      skill: {
        id: 9,
        name: "Javascript",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/javascript.png",
      },
    },
    {
      id: 30,
      category: "프론트",
      skill: {
        id: 10,
        name: "Kotlin",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/kotlin-icon.png",
      },
    },
    {
      id: 31,
      category: "프론트",
      skill: {
        id: 11,
        name: "Notion",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/notion-icon.png",
      },
    },
    {
      id: 32,
      category: "백",
      skill: {
        id: 12,
        name: "PostgreSQL",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/postgresql.png",
      },
    },
    {
      id: 33,
      category: "프론트",
      skill: {
        id: 13,
        name: "React Query",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/react-query-icon.png",
      },
    },
    {
      id: 34,
      category: "협업툴",
      skill: {
        id: 14,
        name: "React",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/react.png",
      },
    },
    {
      id: 35,
      category: "백",
      skill: {
        id: 15,
        name: "Slack",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/slack-icon.png",
      },
    },
    {
      id: 36,
      category: "프론트",
      skill: {
        id: 16,
        name: "Spring",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/spring-icon.png",
      },
    },
    {
      id: 37,
      category: "프론트",
      skill: {
        id: 17,
        name: "Swagger",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/swagger.png",
      },
    },
    {
      id: 38,
      category: "협업툴",
      skill: {
        id: 18,
        name: "Thymeleaf",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/thymeleaf-icon.png",
      },
    },
    {
      id: 39,
      category: "프론트",
      skill: {
        id: 19,
        name: "Tomcat",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/tomcat.png",
      },
    },
    {
      id: 40,
      category: "백",
      skill: {
        id: 20,
        name: "Typescript",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/typescript-icon.png",
      },
    },
    {
      id: 41,
      category: "프론트",
      skill: {
        id: 1,
        name: "AWS EC2",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-ec2.png",
      },
    },
    {
      id: 42,
      category: "백",
      skill: {
        id: 2,
        name: "AWS RDS",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-rds.png",
      },
    },
    {
      id: 43,
      category: "협업툴",
      skill: {
        id: 3,
        name: "AWS S3",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/aws-s3.png",
      },
    },
    {
      id: 44,
      category: "협업툴",
      skill: {
        id: 4,
        name: "Figma",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/figma.png",
      },
    },
    {
      id: 45,
      category: "프론트",
      skill: {
        id: 5,
        name: "Git",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/git-icon.png",
      },
    },
    {
      id: 46,
      category: "프론트",
      skill: {
        id: 6,
        name: "Github Actions",
        iconImageUrl:
          "https://sidepeek-bucket.s3.ap-northeast-2.amazonaws.com/skill/github-actions.png",
      },
    },
  ],
  startDate: "",
  endDate: "",
  ownerId: 1,
  members: [
    // {
    //   id: 1,
    //   role: "PO",
    //   userSummary: {
    //     id: 1,
    //     nickname: "의진",
    //     profileImageUrl:
    //       "https://i.namu.wiki/i/N6_MwKL2hvhgbTGJR_rGAxby09eVQJdnx33clAyVNGcbZI83kXZSNg6OoGQeqTQ0iNWO-CZFZheouxGdEkCLvw.webp",
    //   },
    // },
    // {
    //   id: 2,
    //   role: "프론트",
    //   userSummary: {
    //     id: 2,
    //     nickname: "동건",
    //     profileImageUrl:
    //       "https://user-images.githubusercontent.com/donggun.png",
    //   },
    // },
    // {
    //   id: 3,
    //   role: "오락부짱",
    //   userSummary: {
    //     id: null,
    //     nickname: "민호",
    //     profileImageUrl: null,
    //   },
    // },
    // {
    //   id: 4,
    //   role: "PO",
    //   userSummary: {
    //     id: null,
    //     nickname: "육개",
    //     profileImageUrl: null,
    //   },
    // },
    // {
    //   id: 5,
    //   role: "PO",
    //   userSummary: {
    //     id: null,
    //     nickname: "육개데",
    //     profileImageUrl: null,
    //   },
    // },
    // {
    //   id: 6,
    //   role: "프론트",
    //   userSummary: {
    //     id: null,
    //     nickname: "훈오오",
    //     profileImageUrl: null,
    //   },
    // },
    // {
    //   id: 7,
    //   role: "오락부짱",
    //   userSummary: {
    //     id: null,
    //     nickname: "짱짱맨",
    //     profileImageUrl: null,
    //   },
    // },
  ],
  description:
    "## 이미지가 잘오나?\\n\\n![image](https://velog.velcdn.com/images/gnsdh8616/post/c30b08c8-4221-44b5-bb68-3a66d1917de6/image.gif)\\n\\n## gg",
  troubleShooting:
    // eslint-disable-next-line quotes
    '> 프로젝트가 끝나고 설문조사 답변을 받아 기능을 추가해봤고 그 과정에서 생긴 문제를 작성해봤다.\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/8a079bf4-471b-4590-9ab9-07be88eec909/image.png)\\n\\n서비스에 대해서 설문조사를 진행하였고, DM 페이지 관련해서 메시지를 여러줄로 받을 수 있으면 좋겠다는 요구사항을 전달받았다. DM 메시지를 입력하는 부분을 `input`태그로 구현하는 것이 일반적이라고 생각했는데 다른 분들의 서비스들을 보니 내 방식과 같이 매시지를 한줄로만 입력하여 엔터로 메시지를 보내거나 여러줄을 입력하고 엔터가 아닌 전송버튼을 클릭해서 메시지를 보내는 방식 두가지로 나뉘는듯 했다. 개인적으로 후자의 경우 채팅을 엔터로 보낼 수 없다는 점에서 불편하다 느껴서 내가 한 방식이 옳다고 생각하였지만 이번 기회에 사용자가 많이 이용하는 유명한 서비스의 채팅기능을 꼼꼼히 살펴보았다.\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/c873ae51-8408-4447-a46e-703d0b0ed744/image.gif)\\n\\n인스타그램, 카톡을 포함한 여러 채팅 기능의 경우 shift+enter로 줄바꿈을 하고 줄바꿈에 따라 input상자의 일정크기까지 늘어나고 이후에 크기가 더 늘어날 경우 스크롤이 생기는 방식을 사용하고 있었다. 위에서 언급한 두가지 방식을 합쳐놓은 느낌이어서 편리하다 생각했다.\\n그래서 나도 여러줄로 입력이 가능하면서 엔터로 메시지를 보내도록 기능을 수정해보기로 하였다.\\n\\n### 기존 코드\\n\\n```ts\\nimport * as S from \\"./MessageInput.Styles\\"\\nimport MessageProfile from \\"../../MessageGroupList/MessageProfile\\"\\nimport { useEffect, useState } from \\"react\\"\\nimport useSendMessage from \\"../../../hooks/useSendMessage\\"\\nimport SendIcon from \\"@mui/icons-material/Send\\"\\nimport { AUTH_API } from \\"@/apis/Api\\"\\nimport { DM_PLACEHOLDER_MESSAGE } from \\"@/constants/placeholderMessage\\"\\n\\ninterface MessageInputProps {\\n othersUserId: string\\n}\\n\\nconst MessageInput = ({ othersUserId }: MessageInputProps) => {\\n const [sendingMessage, setSendingMessage] = useState(\\"\\")\\n const { AlertModalComponent, sendMessage } = useSendMessage()\\n const [myProfileImg, setMyProfileImg] = useState(\\"\\")\\n\\n const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n const { value } = e.target\\n setSendingMessage(value)\\n }\\n\\n const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\\n e.preventDefault()\\n const messageSubmission = {\\n message: sendingMessage,\\n receiver: othersUserId,\\n }\\n sendMessage.mutate(messageSubmission)\\n setSendingMessage(\\"\\")\\n }\\n\\n const getMyProfileImg = async () => {\\n const { image } = await AUTH_API.get(`/auth-user`).then((res) => res.data)\\n\\n setMyProfileImg(image)\\n }\\n\\n useEffect(() => {\\n getMyProfileImg()\\n }, [])\\n\\n return (\\n <>\\n {AlertModalComponent}\\n <S.MessageInputLayout>\\n <S.MessageInputForm onSubmit={handleSubmit}>\\n <MessageProfile profileImg={myProfileImg} />\\n <S.MessageInputItem\\n placeholder={DM_PLACEHOLDER_MESSAGE.SEND_MESSAGE_INPUT}\\n onChange={handleInputChange}\\n value={sendingMessage}\\n />\\n <S.MessageSendButton>\\n <SendIcon />\\n </S.MessageSendButton>\\n </S.MessageInputForm>\\n </S.MessageInputLayout>\\n </>\\n )\\n}\\n\\nexport default MessageInput\\n```\\n\\n`MessageInput`컴포넌트는 말그대로 input을 담당하는 컴포넌트다. 여기서 input태그의 보낼 메시지 상태를 관리하고 제출관련한 로직도 담고 있다. 실제 입력이 이뤄지는 `input` 태그는 `MessageInputItem`컴포넌트이다. \\n\\n### textarea를 이용해 여러 줄 입력(엔터로 메시지 보내기 + shift+엔터로 줄바꿈)\\n\\n지금은 `input`태그를 사용하고 있기 때문에 한 줄로만 입력이 가능했다. 따라서 우선 여러줄로 메시지를 입력하기 위해 `textarea` 태그를 이용하였다. 또한, 기존에 입력이나 전송에 관련한 로직을 컴포넌트 안에 두고 있었는데 추상화를 위해 훅으로 따로 관리하였다.\\n\\n```ts\\nconst MessageInput = () => {\\n const { textValue, handleInputChange, handleSubmit, AlertModalComponent } = useTextArea()\\n\\n return (\\n <>\\n {AlertModalComponent}\\n <S.MessageInputLayout>\\n <S.MessageInputForm onSubmit={handleSubmit}>\\n <MessageProfile profileImg={myProfileImg} />\\n <S.MessageInputItem\\n placeholder={DM_PLACEHOLDER_MESSAGE.SEND_MESSAGE_INPUT}\\n onChange={handleInputChange}\\n value={textValue}\\n />\\n <S.MessageSendButton>\\n <SendIcon />\\n </S.MessageSendButton>\\n </S.MessageInputForm>\\n </S.MessageInputLayout>\\n </>\\n )\\n}\\n\\nexport default MessageInput\\n```\\n\\n```ts\\n// 훅\\n\\nimport { useState } from \\"react\\"\\nimport useSendMessage from \\"./useSendMessage\\"\\nimport { useParams } from \\"react-router-dom\\"\\n\\nconst useTextArea = () => {\\n const [textValue, setTextValue] = useState(\\"\\")\\n const { AlertModalComponent, sendMessage } = useSendMessage()\\n const { userId: othersUserId } = useParams()\\n\\n const handleInputChange = (\\n e: React.ChangeEvent<HTMLTextAreaElement>,\\n ): void => {\\n const { value } = e.target\\n if (!value) {\\n return\\n }\\n\\n setTextValue(value)\\n }\\n\\n const handleSubmit = (e: React.FormEvent<HTMLFormElement>): void => {\\n e.preventDefault()\\n if (!othersUserId) {\\n return\\n }\\n\\n const messageSubmission = {\\n message: textValue,\\n receiver: othersUserId,\\n }\\n\\n sendMessage.mutate(messageSubmission)\\n setTextValue(\\"\\")\\n }\\n\\n return { textValue, handleInputChange, handleSubmit, AlertModalComponent }\\n}\\n\\nexport default useTextArea\\n```\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/c30b08c8-4221-44b5-bb68-3a66d1917de6/image.gif)\\n\\n당연히 예상한 결과지만 `textarea`로 바꿨기 때문에 더 이상 엔터로 메시지를 보낼 수 없다..!\\n엔터는 그냥 줄바꿈으로 인식되고, 전송은 오직 클릭버튼을 눌러야만 가능하다..\\n그래서 다른 여러 서비스에서 사용하는 것과 같이 shift+enter를 통해 줄바꿈, enter를 통해 전송을 하도록 구현했다.\\n\\n```ts\\ntype EventType =\\n | React.KeyboardEvent<HTMLTextAreaElement>\\n | React.FormEvent<HTMLFormElement>\\n\\nconst useTextArea = () => {\\n\\n const handleSubmit = (e: EventType): void => {\\n e.preventDefault()\\n if (!othersUserId) {\\n return\\n }\\n\\n const messageSubmission = {\\n message: textValue,\\n receiver: othersUserId,\\n }\\n\\n setTextValue(\\"\\")\\n sendMessage.mutate(messageSubmission)\\n }\\n\\n const handleEnter = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\\n if (!othersUserId) {\\n return\\n }\\n\\n if (e.key === \\"Enter\\" && !e.shiftKey) {\\n handleSubmit(e)\\n }\\n }\\n\\n return {\\n textValue,\\n handleInputChange,\\n handleSubmit,\\n AlertModalComponent,\\n handleEnter,\\n }\\n}\\n\\nexport default useTextArea\\n\\n```\\n\\n엔터를 감지하기위해 기존의 `onChange`이벤트 이외에 `onKeyDown`을 추가해서 오직 enter를 눌렀을때만 전송 이벤트를 호출하도록 하였다.\\n\\n### 메시지가 두번 보내지는 문제\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/14a93d6d-e18a-43d7-a8a1-8100a0868cb2/image.gif)\\n\\n\\n```ts\\nconst handleEnter = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\\n if (e.key === \\"Enter\\" && !e.shiftKey) {\\n handleSubmit(e)\\n }\\n }\\n```\\n위와 같이 구현하니 enter와 shift+enter 이벤트를 구분할 수 있었지만`keydown`이벤트에서만 한글을 입력하고 제출 시 끝의 글자 하나가 중복돼서 보내지는 문제가 있었다. 구글링을 하니 유명한 문제였고 빠르게 해결할 수 있었다.\\n \\n![](https://velog.velcdn.com/images/gnsdh8616/post/898ebf27-7453-4035-98b1-a5399b40a60b/image.png)\\n\\n위 사진을 자세히 보면 글자 입력시 아래 파란색 밑줄이 생긴다. 이 경우 메시지를 보내게 되면 이벤트가 두번 호출되는 문제가 발생하는 것이다. 영어와 다르게 한글은 받침이 존재하기 때문에 글자가 조합 중인지 끝난 상태인지 파악하기 어렵기 때문에 발생하는 문제였다.\\n다행히, 키보드 이벤트의 `isComposing` 함수를 통해 입력된 문자가 조합 문자인지 아닌지를 검증할 수 있었다.\\n\\n```ts\\nconst handleEnter = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\\n // 조합중일 경우 이벤트 막음\\n if (e.nativeEvent.isComposing) {\\n return\\n }\\n\\n if (e.key === \\"Enter\\" && !e.shiftKey) {\\n handleSubmit(e)\\n }\\n }\\n```\\n\\n이제 문자가 조합중이지 않을 경우에만 메시지를 전송하므로 중복출력이 되지 않는다.\\n\\n\\n### textarea의 높이가 자동 조절되지 않는 문제\\n\\n현재는 shift+enter로 줄바꿈이 가능하지만 그에 맞게 textarea의 높이가 늘어나지 않아서 사용자가 현재 입력하고 있는 메시지들의 전체적인 내용을 확인할 수 없는 문제가 있었다. 제일 거슬리는 문제이고 해결하는데 오래걸릴 것 같은 문제였다. 실제로 다른 문제들보다 해결하는데에 시간을 많이 썼다.\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/3608d196-71cd-4863-bd93-e4c3135c78e1/image.png)\\n\\n\\n이 문제를 해결하기 위해선 `scrollHeight`개념을 완전히 이해해야한다.\\n컨텐츠가 보여지는 영역인 `height` 외에 보여지지 않는 부분까지 포함된 `scrollHeight`라는 속성이 존재했고 현재 아무리 줄바꿈을 많이해도 보여지지 않는 부분을 `scrollHeight`가 포함하고 있고 `scrollHeight`는 동적으로 변하지만 `height`는 고정되어있어서 초기에 스타일로 지정한 높이만큼만 보여지는 것이다.\\n\\n따라서, 영역이 늘어남에 따라 `height`영역의 크기를 DOM 접근을 통해(`ref`) `scrollHeight`를 대입하면 문제를 해결할 수 있을 것 같다는 느낌을 받을 수 있다. 하지만, `height`가 내용물의 `height`보다 큰 경우가 존재한다. `content`는 내용물 높이와 1:1로 같은 것이 절대 아니고 비어있는 높이가 존재하기 때문이다. 결국 `cotnent`의 높이는 내용물 높이 + 비어있는 높이이고, `scrollHeight`는 내용물의 높이 + `padding`이 아닌 **`content + padding` + 보여지지 않는 내용물의 높이로 계산해야한다.**\\n이를 왜 고려해야 하냐면 줄바꿈을 여러번 하고 글자들을 다시 지울경우 비어있는 공간이 줄어들지 않는 문제가 발생하기 때문이다.\\n\\n이를 고려한 최종 코드는 다음과 같다.\\n\\n```ts\\n const resize = () => {\\n if (!textRef.current) {\\n return\\n }\\n\\n textRef.current.style.height = \\"0px\\"\\n\\n const scrollHeight = textRef.current.scrollHeight\\n const style = window.getComputedStyle(textRef.current)\\n const borderTop = parseInt(style.borderTop)\\n const borderBottom = parseInt(style.borderBottom)\\n\\n textRef.current.style.height =\\n scrollHeight + borderTop + borderBottom + \\"px\\"\\n }\\n\\n const handleInputChange = (\\n e: React.ChangeEvent<HTMLTextAreaElement>,\\n ): void => {\\n // 생략\\n resize()\\n }\\n\\n const handleSubmit = (e: EventType): void => {\\n // 생략\\n resize()\\n }\\n}\\n\\nexport default useTextArea\\n```\\n\\n우선, `textarea`의 속성을 계산하고 할당해야하므로 `ref`를 이용하였다. 그리고 핵심적인 `resize`함수의 로직은 다음과 같다. `resize`함수는 메시지를 매번 입력시 호출된다.\\n\\n1. `height`를 0으로 설정\\n2. `scrollheight`를 계산\\n3. `height`에 `scrollHeight`대입\\n\\n핵심은 매번 `height`를 0으로 설정하는 것인데 이를 통해 줄바꿈을 해제할때 항상 빈공간의 높이를 고려하여 `scrollHeight`를 계산해줄 수 있다.\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/6a906c01-22ee-4104-990b-47bfb5f3f1f4/image.gif)\\n\\n\\n### 메시지를 보내고 높이가 초기화 되지 않는 문제\\n\\n이제 메시지를 썼다 지웠다 하는 과정에서 `textarea`의 높이는 동적으로 잘 늘어나지만 늘어날때 리스트의 스크롤이 위로 올라가서 최신 메시지가 가려진다는 문제, 메시지를 전송했을 때에는 `input`부분의 높이가 원래대로 돌아오지 않는다는 문제가 있었다.\\n\\n우선, 첫 번째 문제는 기존의 스크롤이 늘어난 만큼 스크롤을 아래로 내려주는 함수를 재활용하였다. 이를 위해서 `textarea`의 높이에 따라서 함수를 호출하려 했는데 \\n\\n기존에는 `MessageInput`외부에서 관리되고 있던 이 함수를 `MessageInput`에서 `textRef`가 변함에 따라 함수를 `props`로 넘겨서 호출하려 했다. 하지만 이후에 `useEffect`를 되도록 지양하기 위해서 상위의 `MessageList`에서 `height`를 state로 관리하고 `resize`마다 이 상태값을 업데이트 하도록하였다.\\n\\n```ts\\n// MessageList.tsx\\n\\n const scrollToBottom = () => {\\n if (scrollRef.current) {\\n scrollRef.current.scrollTop = scrollRef.current.scrollHeight\\n }\\n }\\n\\n useEffect(() => {\\n scrollToBottom()\\n }, [MessageList, messageListHeight])\\n\\n```\\n\\n\\n```ts\\n// 훅\\n const resize = () => {\\n // 생략\\n if (scrollRef.current) {\\n setMessageListHeight(scrollRef.current.clientHeight)\\n }\\n }\\n```\\n\\n두번째 문제는 제출시마다 기존의 `height`로 설정하도록 수정하였다.\\n\\n```ts\\n const handleSubmit = (e: EventType): void => {\\n // 생략\\n\\n // 제출 후 원레 높이로 재조정\\n if (textRef.current) {\\n textRef.current.style.height = \\"18px\\"\\n }\\n }\\n```\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/0be9ca41-4b5e-49ac-b72e-1d97be12db4e/image.gif)\\n\\n\\n\\n### 초기 렌더링시 스크롤 계산 함수가 두 번 호출 되는 문제\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/f77c9f89-c6f6-4df3-a280-1f5f248d7f62/image.gif)\\n\\n```ts\\n const [messageListHeight, setMessageListHeight] = useState(0)\\n\\n const { userId: othersUserId } = useParams()\\n const { data: MessageList } = useMessageList(othersUserId || \\"\\")\\n const scrollRef = useRef<HTMLDivElement>(null)\\n\\n const scrollToBottom = () => {\\n if (scrollRef.current) {\\n scrollRef.current.scrollTop = scrollRef.current.scrollHeight\\n }\\n }\\n\\n useEffect(() => {\\n scrollToBottom()\\n }, [MessageList, messageListHeight])\\n```\\n\\n리액트의 strict 모드의 경우는 렌더링을 두번한다. 하지만, 콘솔을 통해 확인해보니 렌더링이 두번 되고나서 1초 정도뒤에 다시 렌더링이 되는 것을 발견하였다. `useEffect`의 `dependencgy`를 확인해보니`MessageList`라는 서버에서 받는 데이터가 원인이라는 것을 알게 되었다.\\n\\n그래서 서버데이터를 받는 `useQuery` 훅 내부를 살펴보니 문제의 원인을 단번에 알수 있었다.\\n\\n![](https://velog.velcdn.com/images/gnsdh8616/post/27e91b5d-5f4a-419e-9d0b-a45e4c4e00f6/image.png)\\n\\n\\n훅 내부에서 refetch를 1초마다 보내고 있기 때문에 서버에서 받아오는 메시지 리스트의 데이터가 계속 갱신되고 있었고 똑같아 보여도 매번 새로 받아오는 서버 데이터이기 때문에 다른 데이터로 보고 `useEffect`내부의 함수가 실행되는 것이었다.\\n\\n```ts\\n useEffect(() => {\\n scrollToBottom()\\n }, [MessageList?.length, messageListHeight])\\n```\\n\\n따라서, `dependency`를 배열 자체가 아닌 배열의 길이로 수정해서 해결할 수 있었다.\\n\\n\\n\\n\\n\\n## 참고자료\\nhttps://oursmalljoy.com/js-textarea-auto-height-upon-typing/\\nhttps://doqtqu.tistory.com/344',
  comments: [
    {
      id: 1,
      user: {
        id: 3,
        nickname: "세희",
        profileImageUrl: "https://user-images.githubusercontent.com/hailey.png",
      },
      isOwner: false,
      isAnonymous: false,
      content: "우와 이 프로젝트 대박인데요?",
      createdAt: "2024-03-11 00:44:43",
      replies: [
        {
          id: 3,
          parentId: 1,
          user: {
            id: 1,
            nickname: "의진",
            profileImageUrl:
              "https://user-images.githubusercontent.com/uijin.png",
          },
          isOwner: true,
          isAnonymous: false,
          content: "좋게 봐주셔서 감사합니다!",
          createdAt: "2024-03-11 00:44:43",
        },
        {
          id: 6,
          parentId: 1,
          user: {
            id: 4,
            nickname: "훈오",
            profileImageUrl:
              "https://user-images.githubusercontent.com/whoknow.png",
          },
          isOwner: false,
          isAnonymous: false,
          content:
            "세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 ",
          createdAt: "2024-03-11 08:53:25",
        },
        {
          id: 9,
          parentId: 1,
          user: {
            id: 4,
            nickname: "훈오",
            profileImageUrl:
              "https://user-images.githubusercontent.com/whoknow.png",
          },
          isOwner: false,
          isAnonymous: false,
          content:
            "세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세",
          createdAt: "2024-03-11 08:55:45",
        },
      ],
    },
    {
      id: 2,
      user: null,
      isOwner: false,
      isAnonymous: true,
      content: "LGTM ✨💖",
      createdAt: "2024-03-11 00:44:43",
      replies: [],
    },
    {
      id: 4,
      user: {
        id: 3,
        nickname: "세희",
        profileImageUrl: "https://user-images.githubusercontent.com/hailey.png",
      },
      isOwner: false,
      isAnonymous: false,
      content:
        "세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 세 ",
      createdAt: "2024-03-11 08:53:25",
      replies: [],
    },
    {
      id: 5,
      user: null,
      isOwner: false,
      isAnonymous: true,
      content: "LGTM ✨💖",
      createdAt: "2024-03-11 08:53:25",
      replies: [],
    },
    {
      id: 7,
      user: {
        id: 3,
        nickname: "세희",
        profileImageUrl: "https://user-images.githubusercontent.com/hailey.png",
      },
      isOwner: false,
      isAnonymous: false,
      content:
        "세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세세",
      createdAt: "2024-03-11 08:55:45",
      replies: [],
    },
    {
      id: 8,
      user: null,
      isOwner: false,
      isAnonymous: true,
      content: "LGTM ✨💖",
      createdAt: "2024-03-11 08:55:45",
      replies: [],
    },
  ],
}
